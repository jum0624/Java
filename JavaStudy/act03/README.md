# Java Study act 03.


## 01 클래스와 객체

- `클래스`는 사용자가 직접 정의하여 사용할 수 있는 자료형입니다.

> 클래스와 기본 자료형은 형태의 차이점을 갖지만 '형식과 사용 방법을 명시한 실체 없는 틀'이라는 공통점을 갖고 있기 때문에, 자료형 변수가 항상 짝꿍을 이루는 것처럼 클래스 또한 개체와 짝꿍을 이룹니다.

- `객체`는 '클래스'라는 자료형으로 만들어진 변수라고 할 수 있습니다.

> 클래스는 객체가 선언되었을 때 실체를 가지게 되며, 객체를 통해 클래스에 포함된 다양한 데이터를 다룰 수 있게 됩니다.

우리 실생활에서 클래스와 객체를 비유할 수 있는 예시를 살펴봅시다.

	1. 붕어빵 틀 없이 붕어빵이 만들어질 수 없고, 붕어빵 틀은 붕어빵을 만들지 않으면 쓸모 없는 도구가 됩니다.
	
	= 클래스 없이 객체를 만들 수 없고, 클래스는 객체를 만들지 않으면 쓸모 없는 도구가 됩니다.
	
	2. 붕어빵 틀을 사용하기 위해 재료와 사용 메뉴얼을 필요로 하며, 만들 수 있는 붕어빵은 초코붕어빵, 슈크림붕어빵, 팥붕어빵 등 다양합니다.
	
	= 클래스는 멤버 변수와 멤버 메소드로 구성될 수 있으며, 객체는 동일한 틀을 가지나 틀 안에 포함된 내용이 다를 수 있습니다.

### [1-1] 객체

`객체(Object)`란 세상에 존재하는 모든 것을 의미합니다. 즉, 주변에 있는 사물이나 생명체 같은 모든 것들을 말합니다.

프로그래밍에서의 개체는 데이터의 분산을 막기 위해 데이터와 기능을 하나로 묶은 그룹이라고 볼 수 있습니다.

> 예시
> 컴퓨터(PC)=데이터(본체, 모니터, 키보드, 마우스, 스피커 등)+기능(화면제공, 소리, 입력, 출력 등) 

`객체지향`이란 컴퓨터 프로그래밍의 한가지 기법으로 객체를 만들고 객체를 사용하는 프로그래밍 방법을 말한다고 볼 수 있습니다.

다시 말해서 프로그램을 그저 데이터와 처리방법으로 나누는게 아니고, 프로그램을 다수의 "객체"를 만들고, 이들이 서로 상호작용을 통해 만들어지는 방식입니다.

> 컴퓨터(PC)를 예로 들어 보겠습니다. 컴퓨터 한대를 완성하려면 CPU, RAM, BOARD, SSD, HDD, VGA, POWER, CASE 등 여러가지 부품이 있어야 합니다.
> 부품 하나하나가 연결이되고 조립이 되어야 여러분들이 사용하는 컴퓨터의 기능이 제대로 작동되고 사용 할 수있게 됩니다.
> 여기서 컴퓨터 부품(주변기기)들을 객체라고 생각하시면 됩니다.
> 각 부품들의 역할이 나뉘어져 있고 사용하고자 하는 부분에 대해서 각 부품들이 작동을 하게 됩니다.
> 고장이 나더라도 해당 부품만 수리 및 교체를 하면 간단하게 해결할 수 있습니다. 그렇기 때문에 유지보수도 쉽고 편해집니다.
> 즉, 명령어들로 이루어진 목록이 아닌 하나하나의 독립된 "객체"들의 그룹으로 생각하면 되고, 객체간의 메시지를 주고 받음으로서 쉽게 연결이 가능합니다.


#### 객체 생성

우선 다음과 같이 객체를 참조하기 위한 참조 변수를 먼저 선언합니다.

**선언**

> 클래스이름 객체참조변수이름;

**예제**

	Car myCar;

 
그 후에 new 키워드를 사용하여 인스턴스를 생성하고, 해당 인스턴스의 주소를 미리 선언한 참조 변수에 저장하여 사용합니다.

**선언**

> 객체참조변수이름 = new 클래스이름();

**예제**

	myCar = new Car();

 

또한, 다음과 같이 참조 변수의 선언과 인스턴스의 생성을 동시에 할 수도 있습니다.

**선언**

> 클래스이름 객체참조변수이름 = new 클래스이름();

**예제**

	Car myCar = new Car();

자바에서 위와 같은 방법으로 정의한 메소드는 멤버 참조 연산자(.)를 사용하여 호출할 수 있습니다.

자바에서 메소드를 호출하는 방법은 다음과 같습니다.

**문법**

	1. 객체참조변수이름.메소드이름();                  // 매개변수가 없는 메소드의 호출

	2. 객체참조변수이름.메소드이름(인수1, 인수2, ...); // 매개변수가 있는 메소드의 호출

 

다음 예제는 accelerate() 메소드를 호출하는 예제입니다.

**예제**

	Car myCar = new Car();   // 객체를 생성함.
	
	myCar.accelerate(60, 3); // myCar 인스턴스의 accelerate() 메소드를 호출함.

 

다음 예제는 실제로 accelerate() 메소드를 정의하고 호출하는 예제입니다.

> 예제
```Javascript
class Car {

    private int currentSpeed;

    private int accelerationTime;

 

    public void accelerate(int speed, int second) {

        System.out.println(second + "초간 속도를 시속 " + speed + "(으)로 가속함!!");

    }

}

 

public class Method01 {

    public static void main(String[] args) {

        Car myCar = new Car();   // 객체 생성

        myCar.accelerate(60, 3); // 메소드 호출

    }

}

```

> 실행 결과
	3초간 속도를 시속 60(으)로 가속함!!

***

#### 객체지향의 특징

**(1) 캡슐화(Encapsulation)**

`캡슐화`는 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶은 것을 의미합니다.

- 캡슐화된 객체의 세부 내용이 외부에 은폐(정보 은닉)되어, 변경이 발생할 때 오류의 파급 효과가 적습니다.

- 캡슐화된 객체들은 재사용이 용이합니다.

- 객체들 간의 메시지를 주고받을 때 각 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 단순해지고, 객체간의 결합도가 낮아집니다.

**접근제어자**

	public>protected>default>private

- public : 클래스의 외부에서 사용 가능하도록 노출시키는 것이다.

- protected : 다른 클래스에게는 노출되지 않지만, 상속받은 자식 클래스에게는 노출되는 것이다.

- private : 클래스의 내부에서만 사용되며 외부로 노출되지 않는다.

    `정보은닉(Information Hiding)`
    캡슐화에서 가장 중요한 개념으로, 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용하는 것입니다.
    
    1. 각 객체의 수정이 다른 객체에게 주는 영향을 최소화 하는 기술입니다.

    2. 외부 객체가 특정 객체의 데이터와 함수를 직접 접근하여 사용하거나 변경하지 못하므로 유지보수와 소프트웨어 확장 시 오류를 최소화 할 수 있습니다.

![캡슐화](https://blog.kakaocdn.net/dn/d995jb/btqvtPH0URr/g8ABTOlGcMdiUk3r4Bk3K0/img.jpg)

***

**(2) 상속(Inheritance)**

상속은 자식 클래스가 부모 클래스의 특성과 기능을 그대로 물려받는 것을 말한다.

기능의 일부분을 변경해야 할 경우 자식 클래스에서 상속받은 그 기능만을 수정해서 다시 정의하게 되는데,  이러한 작업을 `오버라이딩(Overriding: 재정의)`이라고 한다. 

상속은 캡슐화를 유지하면서도 클래스의 재사용이 용이하도록 해 준다.

***

**(3) 다형성**

하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것을 말한다. 

이를 `오버로딩(Overloading: 중복 정의/다중 정의)`이라고 한다.


	(1) `오버로딩[Overloading]`
	
	같은 기능의 함수에 같은 이름을 사용 할수있어서 가독성 증가
	
	하나의 함수에 여러 메개변수 가능



	조건:
	
	함수명은 동일 해야함.
	
	넘겨주는 인자[메개변수]는 달라야 함.
	
	리턴 타입은 상관 없음.



	(2) `오버라이딩[Overriding]`
	
	상속으로 받은 함수를 그대로 사용하지 않고 새로 만들어서 사용.
	
	코드의 재사용성을 역시 증가 시킨다.
	
	
	조건:
	
	함수명은 동일 해야함.
	
	넘겨주는 인자 같아야 함.
	
	리턴 타입 같아야함.

> 다형성 예시
> 군대에서 나는 K2 소총을 잡았고 동기는 K1 소총을 잡았다. 사격 훈련이 있을 때 중대장이 '준비된 사수부터 발사!'라고 외치면
> 나와 내친구는 명령을 받고 앞의 사로를 향해 총을 쏜다. 이때 중대장은 추상적 객체를 상속받은 모든 객체들에게 명령을 내린것이고
> 그 병사가 총이 뭐든간에 그냥 발사를 하라는 명령을 한것이다.
> 즉, 다형성이 없다면 K1 소총을 든 병사 발사, K2 소총을 든 병사 발사 라며 명령을 하나하나 내려야 할 것이다

***
**(4) 추상화(Abstraction)**

`추상화`는 불필요한 부분을 생략하고 객체의 속성 중 가장 중요한 것에만 중점을 두어 개략화하는것, 즉 모델화를 하는 것입니다.

- 인간이 복잡한 문제를 다루는 데 가장 기본이 되는 방법으로, 완전한 시스템을 구축하기전에 그 시스템과 유사한 모델을 만들어 여러가지 요인들을 테스트할 수 있습니다.

- 추상화는 최소의 비용으로 실제 상황에 대처할 수 있고, 시스템의 구조 및 구성을 가시적으로 볼 수 있습니다.

> 공통의 속성이나 기능을 묶어 이름을 붙이는 것
> 객체 지향적 관점에서 클래스를 정의하는 것을 바로 추상화라고 정의 내릴 수 있겠다.
> 좀 더 살펴보면 물고기, 사자, 토끼, 뱀이 있을 때 우리는 이것들을 각각의 객체라 하며 이 객체들을 하나로 묶으려 할 때, 만약 동물 또는 생물이라는 어떤 추상적인 객체로 크게 정의한다고 하자. 이때 동물 또는 생물이라고 묶는 것을 추상화라고 한다.


> 예시코드
> 스타크래프트에서 유닛을 만든다고 생각을 한다.
> 그러면 기본적으로 들어갈 정보들을 생각 할 수있을 것이다. 그리고 구체화 시켜 나가는 것이다.
> 예를 들어 HP, MP, NAME 과 같은 데이터들과 이동, 공격 과 같은 함수들이 존재 할 것이다.
> 이러한 추상화를 통해서 Class를 만들어 놓고 저글링이나 질럿 마린과 같은 상세한 부분들을 채워 나가는 것이다.

```Javascript
//가상 클래스
//기본적인 몬스터들의 틀[Class] 
//추상 클래스 class Unit{ 

//태어나는 위치 
private : 
	int x; 
	int y; 

//기본 속성 
protected: 
	unsigned char HP; 
	unsigned char MP; 
	char name[20]; 
//생성자 
//태어남 
//소리남 응애응애 
public: 
	Unit(); 
	virtual void born() = 0; 
	virtual void sound() = 0;
 };
```

> [객체지향의 특성 참고]
> <https://richong.tistory.com/122>

***

#### 절차지향과 객체지향

1. 객체 지향 프로그래밍이란?

- 객체 지향 프로그래밍(Object-Oriented Programming), 줄여서 OOP.

- 프로그램을 어떻게 설계해야 하는지에 대한 일종의 개념이자 방법론.

- 프로그램을 단순히 데이터와 처리 방법으로 나누는 것이 아니라, 프로그램을 수많은 '객체'라는 기본 단위로 나누고 이 객체들의 상호작용으로 서술하는 방식입니다. 

- 객체를 데이터의 묶음으로만 착각하기 쉬운데, 그보다는 하나의 '역할'을 수행하는 메소드와 데이터의 묶음으로 봐야 합니다.

**(1) 절차적 프로그래밍 방식**

입력을 받아 명시된 순서대로 처리한 다음, 그 결과를 내는 것

어떻게 어떤 논리를 어떤 순서대로 써나가는 것인가로 간주되었다. 

즉, 프로그램 자체가 가지는 기능에 대해서만 신경을 썼지, 이 프로그램이 대체 어떤 데이터를 취급하는 것인가에는 그다지 관심이 없었던 것이다.

> 객체지향의 반대는 절차지향이 아니고 절차지향의 반대는 객체지향이 아니다.


**(2) 구조적 프로그래밍 방식**

절차적 프로그래밍 방식을 개선하기 위해 나온 방식으로 프로그램을 함수(procedure) 단위로 나누고 프로시져끼리 호출을 하는 것이 구조적 프로그래밍 방식이다. 

프로그램이라는 큰 문제를 해결하기 위해 그것을 몇개의 작은 문제들로 나누어 해결하기 때문에 하향식(Top-down) 방식이라고도 한다.


**(3) 객체 지향 프로그래밍 방식**

구조적 프로그래밍 방식을 개선하기 위해 나온 것으로 객체 지향 프로그래밍이다. 

큰 문제를 작게 쪼개는 것이 아니라, 먼저 작은 문제들을 해결할 수 있는 객체들을 만든 뒤, 이 객체들을 조합해서 큰 문제를 해결하는 상향식(Bottom-up) 해결법을 도입한 것이다. 

이 객체란 것을 일단 한번 독립성/신뢰성이 높게 만들어 놓기만 하면 이후엔 그 객체를 수정 없이 재사용할 수 있으므로 개발 기간과 비용이 대폭 줄어들게 된다.

***

OOP를 사용하면 코드의 중복을 어느 정도 줄일 수 있고 입력 코드, 

계산 코드와 결과 출력 코드 등 코드의 역할 분담을 좀 더 확실하게 할 수 있어서 가독성이 높아질 수 있다.

![](C:\Users\user\Desktop)

절차지향은 데이터를 중심으로 함수를 구현합니다. 이에 반해 객체지향은 기능을 중심으로 메소드를 구현하게 됩니다.

> 객체지향vs절차지향 구현참고
> <http://blog.naver.com/PostView.nhn?blogId=hirit808&logNo=221457311265&categoryNo=35&parentCategoryNo=0&viewDate=&currentPage=1&postListTopCurrentPage=1&from=search>

***

### [1-2] 클래스

#### 클래스의 구성 요소

자바에서 클래스는 멤버(member)로 속성을 표현하는 필드(field)와 기능을 표현하는 메소드(method)를 가집니다.

또한, 클래스는 생성된 객체의 필드를 초기화해주는 특별한 메소드인 생성자(constructor)를 가집니다.

> 예제

```Javascript
public class Car {                    // 접근권한, 클래스 선언, 클래스 이름

    private String modelName;  // 필드(변수)

    private int modelYear;     // 필드(변수)

 

    Car(String modelName, int modelYear) { // 생성자

        this.modelName = modelName;

        this.modelYear = modelYear;

    }

 

    public String getModel() { // 메소드

        return this.modelYear + "년식 " + this.modelName + " " + this.color;

    }

}
```

`필드(field)`

클래스의 필드(field)란 클래스에 포함된 변수(variable)를 의미합니다.

클래스 내에서 필드는 선언된 위치에 따라 다음과 같이 구분됩니다.

1. 클래스 변수(static variable)

2. 인스턴스 변수(instance variable)

3. 지역 변수(local variable)

[필드의 구분 참고]
<http://www.tcpschool.com/java/java_member_field>

***

`메소드(method)`

클래스에서 메소드(method)란 어떠한 특정 작업을 수행하기 위한 명령문의 집합이라 할 수 있습니다.

즉, 메소드를 사용하면 중복되는 코드의 반복적인 프로그래밍을 피할 수 있게 됩니다.

또한, 모듈화로 인해 전체적인 코드의 가독성이 좋아집니다.

그리고 프로그램에 문제가 발생하거나 기능의 변경이 필요할 때도 손쉽게 유지보수를 할 수 있게 됩니다.

***

`생성자(constructor)`

클래스를 가지고 객체를 생성하면, 해당 객체는 메모리에 즉시 생성됩니다.

하지만 이렇게 생성된 객체는 모든 인스턴스 변수가 아직 초기화되지 않은 상태입니다.

따라서 자바에서는 객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있는 생성자(constructor)라는 메소드를 제공합니다.

자바에서 생성자(constructor)의 이름은 **해당 클래스의 이름과 같아야** 합니다.

> 즉, Car 클래스의 생성자는 Car()가 됩니다.

***

## 02 생성자

자바에서는 객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있는 생성자(constructor)라는 메소드를 제공합니다.

### [2-1] 생성자의 특징 

1. 생성자는 반환값이 없지만, 반환 타입을 void형으로 선언하지 않습니다.

2. 생성자는 초기화를 위한 데이터를 인수로 전달받을 수 있습니다.

3. 객체를 초기화하는 방법이 여러 개 존재할 경우에는 하나의 클래스가 여러 개의 생성자를 가질 수 있습니다.

    즉, 생성자도 하나의 메소드이므로, 메소드 오버로딩이 가능하다는 의미입니다.

4. 자바에서 생성자(constructor)의 이름은 해당 클래스의 이름과 같아야합니다.
 
다음 예제는 Car 클래스를 선언하면서 여러 개의 생성자를 선언하는 예제입니다.

**예제**
```Javascript

Car(String modelName) {}

Car(String modelName, int modelYear) {}

Car(String modelName, int modelYear, String color) {}

Car(String modelName, int modelYear, String color, int maxSpeeds) {}

```
### [2-2] 생성자의 선언

자바에서 클래스 생성자를 선언하는 문법은 다음과 같습니다.

**문법**

1. 클래스이름() { ... }                  // 매개변수가 없는 생성자 선언

2. 클래스이름(인수1, 인수2, ...) { ... } // 매개변수가 있는 생성자 선언

 

위와 같이 생성자 중에는 매개변수를 전달받아 인스턴스 변수를 초기화하는 생성자도 선언할 수 있습니다.

 

다음 예제는 앞서 살펴본 Car 클래스의 생성자를 선언하는 예제입니다.

> 예제
```Javascript
Car(String modelName, int modelYear, String color, int maxSpeeds) {

    this.modelName = modelName;

    this.modelYear = modelYear;

    this.color = color;

    this.maxSpeed = maxSpeed;

    this.currentSpeed = 0;

}

```

> 위의 예제처럼 클래스의 생성자(constructor)는 어떠한 반환값도 명시하지 않음에 주의해야 합니다.

## 03 this와 this()

**(1) this 참조 변수**

`this 참조 변수`는 인스턴스가 바로 자기 자신을 참조하는 데 사용하는 변수입니다.

이러한 this 참조 변수는 해당 인스턴스의 주소를 가리키고 있습니다.

 

다음 예제는 Car 클래스의 생성자를 나타낸 예제입니다.

> 예제
```Javascript
class Car {

    private String modelName;

    private int modelYear;

    private String color;

    private int maxSpeed;

    private int currentSpeed;

 

    Car(String modelName, int modelYear, String color, int maxSpeed) {

        this.modelName = modelName;

        this.modelYear = modelYear;

        this.color = color;

        this.maxSpeed = maxSpeed;

        this.currentSpeed = 0;

    }

    ...

}

``` 

위의 예제처럼 생성자의 매개변수 이름과 인스턴스 변수의 이름이 같을 경우에는 인스턴스 변수 앞에 this 키워드를 붙여 구분해만 합니다.

 

이렇게 자바에서는 this 참조 변수를 사용하여 인스턴스 변수에 접근할 수 있습니다.

이러한 this 참조 변수를 사용할 수 있는 영역은 인스턴스 메소드뿐이며, 클래스 메소드에서는 사용할 수 없습니다.

모든 인스턴스 메소드에는 this 참조 변수가 숨겨진 지역 변수로 존재하고 있습니다.


**(2) this() 메소드**

`this() 메소드`는 생성자 내부에서만 사용할 수 있으며, 같은 클래스의 다른 생성자를 호출할 때 사용합니다.

this() 메소드에 인수를 전달하면, 생성자 중에서 메소드 시그니처가 일치하는 다른 생성자를 찾아 호출해 줍니다.

 
> 메소드 시그니처(method signature)란 메소드의 이름과 메소드의 원형에 명시되는 매개변수 리스트를 가리킵니다.
 

다음 예제는 this 참조 변수와 this() 메소드를 사용한 예제입니다.

> 예제
```Javascript
class Car {

    private String modelName;

    private int modelYear;

    private String color;

    private int maxSpeed;

    private int currentSpeed;

 

    Car(String modelName, int modelYear, String color, int maxSpeed) {

        this.modelName = modelName;

        this.modelYear = modelYear;

        this.color = color;

        this.maxSpeed = maxSpeed;

        this.currentSpeed = 0;

    }

 

    Car() {

        this("소나타", 2012, "검정색", 160); // 다른 생성자를 호출함.

    }

 

    public String getModel() {

        return this.modelYear + "년식 " + this.modelName + " " + this.color;

    }

}

 

public class Method05 {

    public static void main(String[] args) {

        Car tcpCar = new Car(); System.out.println(tcpCar.getModel());

    }

}

```

> 실행 결과
	2012년식 소나타 검정색

 

위의 예제에서 매개변수를 가지는 첫 번째 생성자는 this 참조 변수를 사용하여 인스턴스 변수에 접근하고 있습니다.

또한, 매개변수를 가지지 않는 두 번째 생성자는 내부에서 this() 메소드를 이용하여 첫 번째 생성자를 호출합니다.

이렇게 내부적으로 다른 생성자를 호출하여 인스턴스 변수를 초기화할 수 있습니다.

 

> 단, 한 생성자에서 다른 생성자를 호출할 때에는 반드시 해당 생성자의 첫 줄에서만 호출할 수 있습니다.
